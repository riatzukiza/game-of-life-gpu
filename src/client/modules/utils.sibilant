(include "kit/header"
         "../../inc/async")

(import-namespace async)
(import-namespace kit)

(include "../../inc/misc.sibilant")

(require! dl 'deeplearn
          m 'mathjs
          'events)



(macro in (  o k) [k " in " o])

(macro sprint (...args) `(print ...@(Array.bind args (=> (a) [`(quote @a) a]))))

(macro set-globals (...body) `(mixin (lit ...@body) global))

(macro fluently (...body) `(scoped ...@body))

(macro accumulate (name ...body) `(assign @name (pipe @name ...@body)))

(def-lit-macro def-curried (name args ...body) `(property @name (R.curry (lambda @args ...@body))))

(def-lit-macro define (name parent ...body)
  `(property @name
             (.define @parent (quote @name)
                      (lit ...@body))))



(macro remember (m k ...body)
       `(if (.has @m @k)
            (.get @m @k)
          (do (var r (scoped ...@body))
              (.set @m @k r) r)))

(macro collect (name value ...body)
       `(.call (lambda (@name) ...@body @name) this @value))

(macro array-of (size ...body)
       `(collect array []
                 (do-times @size (.push array (scoped ...@body)) array)))

(macro fourth (a) `(get @a 3))

(def-lit-macro gett-tuple (name ...keys)
  `(gett @name [...@(.map keys (=> (k) `(get this @k)))]))

(macro array-of (size ...body)
       `(collect array []
                 (do-times @size (.push array (scoped ...@body)))))

(def Event-emitter.remove-all-listeners ((dots args))
     (.call events.Event-emitter.prototype.remove-all-listeners
            this
            (dots args)))


(def rgb (r g b ) (lit  r g b ))
(export rgb)

(def memoize (f)

     "create a memoized version of any function. A memoized function will return
previously calculated results from a cache if the arguments given to it are the same"

     (var m {})

     (cond R.has R.prop (=> ((dots args)) (f.apply this args))))
(export memoize)

(var set-value (R.curry (=> (value entity) (assign entity.value value))))
(export set-value)

(var (lit ( not fnot) (pipe fpipe) equals) R)
(export not)
(export fpipe)
(export equals)

(def Object.prototype.each (f)
     (each (Object.keys this) (k)
           (f (get this k) k)))




(var curry R.curry)
(export curry)

(def-curried fmap (f a) (.map a f))
(export fmap)

(def-curried fset (o k v) (set o k v))
(export fset)

(def window.size () [window.inner-width window.inner-height])

(def-curried search  (value array) (.find array (=> (v) (= v value))))
(export search)

(def identity (a) a)
(export identity)

(def search-if-given ( array value)
     (conditional array

                  (-> (defined? value)) (search value)

                  identity))
(export search-if-given)

(def fprint ($value (dots args))
     (console.log $value (dots args))
     $value)
(export fprint)

(def-curried feach (f a) (.each a f)) 
(export feach)
