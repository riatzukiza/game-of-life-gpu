
(def free-space (pool) pool.free)
(def sum-of (list f) (.map list))
(def List.reduce (f r) (.each this (=> (e i l) (assign r (f r e i l)))) r)
(def-generic List.find-node (f (node this.head))
  (if (f node)
      node
      (not (= node this.tail))
      (List.find f node.next)
      false))
(def-generic List.find (f (node this.head))
  (var r (List.find-node f node))
  (if r r.value false))

(def List.rotate ()
  (fluently (.push this (.shift this))))

(def-generic List.rotate-until (predicate (t 0))
  (if (predicate this.head.item)
      this.head.item
      (not (> t this.size))
      (pipe this .rotate (.rotate-until predicate (++ t)))
      false))


;;(var x (List.of 1 2 3 4 5))
;;(.rotate-until x (#-> (= 5)))
;;(assert (= x.head 5))

(define Dynamic-pool Interface
  (bucket-size 256)
  (init (interface bucket-size (buckets  (List.of ((create Object-pool) this.bucket-size interface)))))

  (gett current this.buckets.head.item)
  (gett size (sum-of this.buckets free-space))

  (def-generic grow ( buckets  bucket-size (self this))
    (collect new-pool ((create Object-pool) bucket-size this.interface)
             (.unshift buckets new-pool)))

  (def-generic adjust (buckets)
    (var p (.rotate-until buckets (#-> (get 'free) (> 0))))
    (ternary p p (.grow this)))

  (def-generic aquire ( buckets )
    (collect object (if this.current.free
                        (.aquire this.current)
                        (pipe this .adjust .aquire ))
             (assign object.bucket this.current)))

  (def-generic release (object buckets )
    (.release object.bucket object))

  (def-generic clear (buckets)

    (var self this)

    (.each buckets (#-> (get '*in-use) (.each (#-> self.despawn)))))

  (def spawn ((dots args))

    "aquire an object from the systems pool, and initialize it."

    (collect r (pipe this .aquire)
             (print "spawning" r )
             (print "with init" r.init)
             (.init r (dots args))))

  (def despawn (obj)
    "remove an object from the system, and release it back into the pool."

    (.clear obj)
    (.release this obj))

  (def register (interface)

    "Associate an interface with a system,and add the system to the collection of all active systems."

    (assign interface.pool this)))
