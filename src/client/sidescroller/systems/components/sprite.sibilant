
(require! jimp "jimp")

(macro remember (m k ...body)
       `(if (.has @m @k)
            (.get @m @k)
            (do
             (var r (scoped ...@body))
             (.set @m @k r) r)))

(macro collect (name value ...body)
       `(.call (lambda (@name) ...@body @name) this @value))

(macro array-of (size ...body)
       `(collect array []
                 (do-times @size (.push array (scoped ...@body)) array)))

(macro fourth (a) `(get @a 3))

(def-interface Pixel (x y image (tuple (array-of 4 (get image.bitmap.data   (+ (image.get-pixel-index x y)  i)))))
  (gett r (first this.tuple))
  (gett g (second this.tuple))
  (gett b (third this.tuple))
  (gett a (fourth this.tuple)))

(include "../../matrix-map.sibilant")

(def-interface Image

    (image
     (pixel-map ((create Matrix-map) [image.bitmap.width image.bitmap.height])))


  (gett bitmap this.image.bitmap.data)

  (gett create (=> (image) ((create this) image)))

  (def load (path)
    (pipe (.read jimp path)
          (.then Image.create)))
  (def load-list ((dots paths))
    (pipe (fmap   (#-> jimp.read) paths)
          Promise.all
          (.then (fmap Image.create))))

  (def-generic get ([x y] bitmap)
    (var self this)
    (remember self.pixel-map [x y] ((create Pixel) x y this.image)))

  (def-generic scan (f image bitmap)
    (for (x 0) (> x image.width) (++ x)
         (for (y 0) (> y image.width) (++ y)
              (f (.get this [x y]) [x y] this)))))


(define Sprite-interface Component

  (def-generic register (dim system)
    (assign this.verts ((create Matrix-map) dim
                        (array-of (product-of dim)
                                  (.spawn system.verts ))))) 
  (frame-id 0),

  (delay 1) ;; number of ticks between frames

  (gett pos (.get Position this.entity))

  (gett dim this.data.dim),
  (gett image (.resolve Promise this.data.image)),
  (gett frame-count this.data.frame-count),
  (gett scale this.data.scale)
  (gett orientation this.data.orientation )

  (gett height (second this.dim))
  (gett width (first this.dim))

  (gett x this.pos.x)
  (gett y this.pos.y)


  (def-generic get-frame-pixel (i j bit-map width frame-id frame-count image)
    (.get  bit-map [(+ i (* width (mod   frame-id frame-count))) j]))

  (def-generic move-vertex (i j scale v pos height width orientation)
    (set v.point
         'x (mod (+ (- pos.x (/ (* width scale (first orientation)) 2))
                    (* i scale (first orientation)))
                 (first rendering.dimensions))

         'y (mod (+ (- pos.y (/ (* height scale (second orientation)) 2))
                    (* j scale (second orientation)))
                 (second rendering.dimensions))

         'z 0))

  (def set-color (v pixel)
    (set v.color
         'r pixel.r
         'g pixel.g
         'b pixel.b
         'a pixel.a))

  (def step () (assign this.frame-id (mod (+ this.frame-id 1) this.frame-count)))

  (def-generic draw (t verts image scale frame-id frame-count pos height width)
    (then image bit-map
          ( .each verts (=> (v [i j])
                            (var pixel (.get-frame-pixel this i j bit-map))

                            (.move-vertex this i j scale v)
                            (set v 'size scale)
                            (.set-color this v pixel))))))

(define Sprite Component-system
  (verts (.spawn rendering 1000000 Vertex
                 [ uniforms.res uniforms.scale]
                 [(vert-shader) fragment-shader-string]))
  (interface Sprite-interface)

  (def *update-component (sprite t)
    (.draw sprite t)))

