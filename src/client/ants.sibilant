(include "kit/header")

(import-namespace kit)

(include "kit-interface/header")

(import-namespace interface)

(include "kit-html/src/dom")
(import-namespace dom)


(require! 'assert)

;; should make this detect if we are compiling, or running dynamicly
;; but this will do for now, because I usually am only running a compiler
;; instance in electron when I am repling
(require! Path "path")
(assign module.filename (Path.join (process.cwd) "./src/client/antity.sibilant"))
(meta
 (when (defined? process.versions.electron)
   (print "defining macro require for electron context")
   (def macros.require (name)
        `(let ((*require global.require)
               (path (global.require "path"))
               (name @name))

           (var module-path (path.dirname module.filename))
           (print "requiring" name "from" module-path)
           (*require (if (= (first name) ".")
                         (path.join module-path name)
                       name
                       )))))
 null)

(set global
     'create create
     'extend extend
     'mixin mixin)

(require! (lit Rendering) "./modules/systems/rendering/rendering"
          (lit Scalar) "./modules/math/scalar"
          (lit fmap) "./modules/utils"
          (lit Position) "./modules/systems/position"
          (lit Velocity) "./modules/systems/velocity"
          (lit Dot) "./modules/systems/rendering/dot"
          (lit Physics Gravity Friction) "./modules/systems/physics"
          (lit Collision) "./modules/systems/collision"
          (lit Game) "./modules/game"
          (lit Keyboard) "./modules/keyboard"
          (lit Component System) "./modules/ecs/component")





(var green (color 0 255 0) yellow (color 255  255  0))

(var despawned (fpipe .despawn))


(const rendering (.load Rendering
                        (lit (size (.sub Scalar  (window.size) 8))
                             (limit 100)
                             (blend true))))

(.resize rendering (.sub Scalar  (window.size) 4))

(assign rendering.background-color
        (lit (r 0)
             (g 0)
             (b 0)
             (a 150)))


(var wrap Document-node.wrap)

(var stage (dom (.div .id 'stage )))


(var container
     (dom
      (.div .id "container"
            rendering.context.canvas)))
(with-dom Document-root
          (.div .id 'frame container))

(macro random-sign  ( ) `(if (< (Math.random) 0.5) -1 1))


(var game ((create Game) rendering [,Physics  Velocity  Collision ,Position   Dot,]))

(var movable-dot [ Position Velocity Dot    Physics Collision]
     physics-dot [Position Dot  Velocity  Physics Collision]

     UP -1 DOWN 1 LEFT -1 RIGHT 1)

(on (.remove-all-listeners game.events 'collision)

    'collision ([c c* d])

    (var [d1x d1y d2x d2y] : d,

         max : (Math.max.apply null d)
         min : (Math.min.apply null d))


    (var physics (.get game.systems Physics c.entity))


    (when (= c.type 'dynamic)


      (when (or (= d1x max)
                (= d2x max))
        (set c.pos 'x (+ c.pos.x
                         (if (= d1x max) -1 1)
                         (* max (if (= d1x max) 1 -1))))

        (set c.velocity.xd 0))

      (when (or (= d1y max)
                (= d2y max))
        (set c.pos 'y (+ c.pos.y
                         (if (= d1y max) -1 1)
                         (* max (if (= d1y max) 1 -1))))
        (set c.velocity.yd 0))))


(def position (x y) (lit x y))

(def velocity (xd yd) [xd yd])

(def dot (r g b a)
     (lit r g b a))

(def physics (mass scale forces)
     (lit mass scale forces
          (falling false)))

(def sprite (image frame-count scale dim)
     (lit image frame-count scale dim))

(def collision (type)
     (lit type))

(def entity (aspects data)
     (.spawn game.ent aspects data))

(def random-ubyte () (random-int 0 255))

(def create-ant ([x y])
     (var ant (entity physics-dot
                      [(position x y)
                       (dot 255 0 0 255)
                       (velocity 0 0)
                       (physics 10 10 [])
                       (collision 'dynamic)]))
     (.push ants ant)
     ant)

(require! (lit Matrix-view Matrix) "./modules/data-structures/contrib")
(var ants [])

(var ant (create-ant [200 200]))

(macro random-sign  ( ) `(if (> (Math.random) 0.5) -1 1))
(require! tf "@tensorflow/tfjs")

(def-async random-move (ent)

  (var velocity (.get game.systems Velocity ent )
       pos (.get game.systems Position ent))

  (var w (await (.data weights)))
  (var m [])
  (for! (i -1) (< i 2) (++ i)
        (for! (j -1) (< j 2) (++ j)
              (var rel [i j])
              (var k ( Matrix-view.get-index
                       [(Math.round (/ pos.x 32)) (Math.round (/ pos.y 32))]
                       rel
                       (+ (/ (second (window.size)) 32) 3)
                       ))
              (.push m [rel (get w k)])))
  (var k ( Matrix.get-index
           [(Math.round (/ pos.x 32)) (Math.round (/ pos.y 32))]
           (second (window.size))))
  (set w k (+ 0.001 (get w k)))
  (.accelerate velocity (.reduce m (=> ([xv yv] [[i j] *w])
                                       [(or (+ xv (* i *w)) 0)
                                        (or (+ yv (* j *w)) 0)])
                                 [0 0])))
(set (.get game.systems Position
           (first ants))
     'x 200
     'y 200)
(def create-ant ([x y])
     (var ant (entity physics-dot
                      [(position x y)
                       (dot 255 0 0 255)
                       (velocity 0 0)
                       (physics 10 10 [])
                       (collision 'dynamic)]))
     (.push ants ant)
     ant)
;; (pipe (weights.data)
;;       (.then (=> (d)
;;                  (for! (i 0) (> i (/ (first (window.size) ) 32)) (++ i)
;;                        (for! (j 0) (> j (/ (second (window.size) ) 32)) (++ j)
;;                              (entity [Position Dot Physics]
;;                                      [(position (* i 32) (* j 32))
;;                                       (dot 0 255 0)]))))null ))




;; (require! (lit Vertex) "./modules/systems/rendering/vertex"

;;           (lit uniforms vert-shader fragment-shader-string) "./modules/gl")

;; (def vertex-layer (limit game)
;;      (.spawn game.rendering limit Vertex
;;              [ uniforms.res uniforms.scale]
;;              [(vert-shader) fragment-shader-string]))

;; (define Weight-interface Component

;;   (gett color this.data)
;;   (gett pos (.get this.system.process.systems Position this.entity))
;;   (gett scale (get (.get this.system.process.systems Physics this.entity) 'scale))
;;   (gett vertex this.data.vertex))
;; (export Dot-interface)

;; (define Weight System
;;   (def register ()
;;        (assign this.verts (vertex-layer 100000 this.game)))

;;   (interface Dot-interface)

;;   (def spawn (entity data)
;;        (assign data.vertex (.spawn this.verts))
;;        (var c (.call System.spawn this entity data))
;;        c)

;;   (def *update-component (dot)
;;        (set dot.vertex.point
;;             'x dot.pos.x
;;             'y dot.pos.y

;;             'z 0)
;;        (set dot.vertex
;;             'size dot.scale)
;;        (set dot.vertex.color
;;             'r dot.color.r
;;             'g dot.color.g
;;             'b dot.color.b
;;             'a dot.color.a)))

;; (export Dot)

;; (def create-weight-dot ()
;;      )

(def product-of (a) (.reduce a (=> (value e) (* value e)) 1))
(product-of (window.size))

(def-async move-ants ()
  (await (Promise.all (.map ants random-move)))
  (weights.assign (tf.tidy (-> (.sub weights (.scalar tf 0.00001)))))
  )

(var weights (tf.variable (tf.random-uniform (.map (window.size) (#-> (/ 32) (Math.ceil))))))

(.on game.events 'tick (-> (move-ants )))
(.start game)
